---
layout: post
title: 简单命令行使用之top
---
<img src="{{ site.url }}/images/post/exp-top.jpg" class="excerpt">
最近使用命令行（linux）进行检测系统的cpu实时性能，感觉linux的top命令非常的时候，而且还有一些小技巧，真的是超好用。我是属于见过的东西有印象，但是不能清晰想出来，只能这样记录一下，主要是把工作中的主要内容记录一下，由于mac上的便利贴已经贴满一屏了，所以为了以后方便使用，挂在自己的博客上了，希望对大家也有帮助，想看了随时过来查查。

<!-- ## -->

![]({{ site.url }}/images/post/exp-top.jpg)

最近开发服务器程序，需要查看实时cpu，故简单的检测就是采用了linux的top命令，top工具用来查看当前系统的进程的一些信息，虽然很多列的信息我不知道，但是我只关注cpu和内存就可以了，so just use it！

##top命名使用
------------------------------------
首先你得进入linux命令行界面，输入top，然后回车就可以进入了，如下图

![]({{ site.url }}/images/post/exp-top-use1.jpg)

![]({{ site.url }}/images/post/exp-top-use2.jpg)

##监控界面的各个列代表什么指标？
*	PID         进程ID
*	%CPU        系统cpu
*	%MEM        系统内存
*	COMMAND     进程启动的程序

以上就是我知道和常用的指标，不要问我其他的为什么不一起说说，很抱歉，目前我够用了，你不够用，自己google

##只是这么用还有什么意义？
OK，我最近经常这么用

\# top -p 1400,1545

\#

\#


回车后显示如下：

![]({{ site.url }}/images/post/exp-top-use3.jpg)

通过` top -p pid1,pid2,pid3 `这个命令可以集中查看你想看的某些进程（怎么知道进程ID：`ps -ef|grep mysql` 或 `pgrep mysql`）

如果在上的显示界面中想按照某个列进行排序，可以`shift+o`（大写的欧）进入选择列排序界面

![]({{ site.url }}/images/post/exp-top-use4.jpg)

在界面上，可以根据选择要排序，通过按键盘上面的字母键，如想选择`PID`，则按下字母` a `键，就会选中该列
回车即可进行排序（倒序，由大到小）

![]({{ site.url }}/images/post/exp-top-use5.jpg)

查看top的参数说明`top -h`

![]({{ site.url }}/images/post/exp-top-use6.jpg)



---
##参考资料

<http://man.chinaunix.net/linux/lfs/htmlbook/appendixa/procps.html>

<http://baike.baidu.com/item/top/16179030#1>












###文字描述下吧：
启动node cluster模式运行，虚拟机cpu共12核
起初运行正常，随着socket connection的连接数不断增多，cpu呈现指数型上涨
连接数仅仅不到2000个，在短短的十几分钟内cpu就100%满负荷了，任何的业务都没有响应。
以上就是使用redisStore模式的socket.io

###对比单机版说明：
采用默认的memory模式的socket.io运行的单node
服务器接受2000个连接很稳定，cpu在10%左右，高峰达到30%（我的业务里面有个大递归占用cpu相对来说比较大）
   
##github ISSUES 列表
------------------------------------
1.	[CPU 100% with Redis Store #862](https://github.com/Automattic/socket.io/issues/862)
2.	[Handshakes leaking when using RedisStore #1064](https://github.com/Automattic/socket.io/pull/1064/files)
3.	[Use static channels for node syncing. #1371](https://github.com/Automattic/socket.io/pull/1371/files)

以上是同一个bug问题的两种解决方案，第1、2是采用的局部小改动，由于pub和sub的问题，只是针对bug解决问题，而第3种采用新的设计思路，
从另一个思路解决redis发布订阅效率问题。

###第1,2解决方案
修改lib/manager.js
由于0.9.16的redis订阅是根据socket的sessionid进行订阅的，所以当网络连接断开的时候，没有把从redis订阅的disconnect:id等的主题取消订阅，
运行一段时间后就会出现订阅一直存在，而且越积越多，对于cpu的消耗会很大。

###第3种解决方案
由于之前采用定于的方式是和socket的sessionid进行绑定的，一个连接就会有5个订阅，由此可见如果有1000个连接的话就会有5000个订阅，
这个消耗cpu会相当厉害。“24”提交了新的思路，就是一个socket.io server只订阅5个主题（message-remote、disconnect-remote、heartbeat-clear、disconnect-force、dispatch-remote），
不在根据sessionid进行动态订阅，而是静态订阅五个频道，而是在主题的数据区来区分socket，这五个订阅会一直随着进程存在而存在，直到进程关闭或者redis连接断开。


##升级你的socket.io到0.9.17版本
如果你用的socket.io是0.9.16那么最好还是升级到0.9.17，因为一旦采用cluster模式和socket.io的redisStore模式，必然会出现这个问题
不用害怕，看完这篇报告，你就放心大胆的升级吧，因为0.9.17版本和0.9.16版本的差别不大,对比图：

![]({{ site.url }}/images/post/socket.io-bug-deff.jpg)

###官方的release document 0.9.17 / 2014-05-22
*	use static channels for remote syncing instead of subscribing/unsubscribing 5 channels for every connection
*	Use destroy buffer size on websocket transport method as well
*	http-polling : adding 'X-XSS-Protection : 0;' to headers necessary not only to jsonp-polling but http-polling



---
##参考资料

<https://github.com/Automattic/socket.io/blob/0.9.17/History.md>

<https://github.com/Automattic/socket.io/issues/1303>

<https://github.com/Automattic/socket.io/issues/862>

<https://github.com/Automattic/socket.io/pull/1371>

















